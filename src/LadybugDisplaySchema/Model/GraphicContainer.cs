/* 
 * Ladybug Graphic Schema
 *
 * Documentation for Ladybug graphic schema
 *
 * Contact: info@ladybug.tools
 * Generated by: https://github.com/openapitools/openapi-generator.git
 */

using System;
using System.Linq;
using System.IO;
using System.Text;
using System.Text.RegularExpressions;
using System.Collections;
using System.Collections.Generic;
using System.Collections.ObjectModel;
using System.Runtime.Serialization;
using Newtonsoft.Json;
using Newtonsoft.Json.Converters;
using System.ComponentModel.DataAnnotations;


namespace LadybugDisplaySchema
{
    /// <summary>
    /// Graphic container used to get legends, titles, and colors for any graphic.
    /// </summary>
    [Serializable]
    [DataContract(Name = "GraphicContainer")]
    public partial class GraphicContainer : OpenAPIGenBaseModel, IEquatable<GraphicContainer>, IValidatableObject
    {
        /// <summary>
        /// Initializes a new instance of the <see cref="GraphicContainer" /> class.
        /// </summary>
        [JsonConstructorAttribute]
        protected GraphicContainer() 
        { 
            // Set non-required readonly properties with defaultValue
            this.Type = "GraphicContainer";
        }
        
        /// <summary>
        /// Initializes a new instance of the <see cref="GraphicContainer" /> class.
        /// </summary>
        /// <param name="values">An list of numerical values that will be used to generate the legend and colors. (required).</param>
        /// <param name="geometry">An optional ladybug-geometry object (or list of ladybug-geometry objects) that is aligned with the input values. If a Mesh or Polyface is specified here, it is expected that the number of values match the number of faces or the number of vertices. If a list of geometry objects is specified (ie. a list of Point3Ds), it is expected that the length of this list align with the number of values..</param>
        /// <param name="minPoint">A Point3D object for the minimum of the bounding box around the graphic geometry. If None, then there must be an input for geometry and the bounding box around this geometry will be used to set up the graphic container..</param>
        /// <param name="maxPoint">A Point3D object for the maximum of the  bounding box around the graphic geometry. If None, then there must be an input for geometry and the bounding box around this geometry will be used to set up the graphic container..</param>
        /// <param name="legendParameters">An Optional LegendParameters object to override default parameters of the legend. None indicates that default legend parameters will be used..</param>
        /// <param name="dataType">Optional DataType from the ladybug datatype subpackage (ie. Temperature()) , which will be used to assign default legend properties. If None, the legend associated with this object will contain no units unless a unit below is specified..</param>
        /// <param name="unit">Optional text string for the units of the values. (ie. \&quot;C\&quot;). If None, the default units of the data_type will be used. (default to &quot;&quot;).</param>
        public GraphicContainer
        (
           List<double> values, // Required parameters
           AnyOf<Mesh2D, Mesh3D, Polyface3D, List<AnyOf<Mesh2D, Mesh3D, Polyface3D>>> geometry = default, Point3D minPoint= default, Point3D maxPoint= default, LegendParameters legendParameters= default, DataType dataType= default, string unit = ""// Optional parameters
        ) : base()// BaseClass
        {
            // to ensure "values" is required (not null)
            this.Values = values ?? throw new ArgumentNullException("values is a required property for GraphicContainer and cannot be null");
            this.Geometry = geometry;
            this.MinPoint = minPoint;
            this.MaxPoint = maxPoint;
            this.LegendParameters = legendParameters;
            this.DataType = dataType;
            // use default value if no "unit" provided
            this.Unit = unit ?? "";

            // Set non-required readonly properties with defaultValue
            this.Type = "GraphicContainer";

            // check if object is valid, only check for inherited class
            if (this.GetType() == typeof(GraphicContainer))
                this.IsValid(throwException: true);
        }

        //============================================== is ReadOnly 
        /// <summary>
        /// Gets or Sets Type
        /// </summary>
        [DataMember(Name = "type")]
        public override string Type { get; protected set; }  = "GraphicContainer";

        /// <summary>
        /// An list of numerical values that will be used to generate the legend and colors.
        /// </summary>
        /// <value>An list of numerical values that will be used to generate the legend and colors.</value>
        [DataMember(Name = "values", IsRequired = true)]
        public List<double> Values { get; set; } 
        /// <summary>
        /// An optional ladybug-geometry object (or list of ladybug-geometry objects) that is aligned with the input values. If a Mesh or Polyface is specified here, it is expected that the number of values match the number of faces or the number of vertices. If a list of geometry objects is specified (ie. a list of Point3Ds), it is expected that the length of this list align with the number of values.
        /// </summary>
        /// <value>An optional ladybug-geometry object (or list of ladybug-geometry objects) that is aligned with the input values. If a Mesh or Polyface is specified here, it is expected that the number of values match the number of faces or the number of vertices. If a list of geometry objects is specified (ie. a list of Point3Ds), it is expected that the length of this list align with the number of values.</value>
        [DataMember(Name = "geometry")]
        public AnyOf<Mesh2D,Mesh3D,Polyface3D, List<AnyOf<Mesh2D,Mesh3D,Polyface3D>>> Geometry { get; set; } 
        /// <summary>
        /// A Point3D object for the minimum of the bounding box around the graphic geometry. If None, then there must be an input for geometry and the bounding box around this geometry will be used to set up the graphic container.
        /// </summary>
        /// <value>A Point3D object for the minimum of the bounding box around the graphic geometry. If None, then there must be an input for geometry and the bounding box around this geometry will be used to set up the graphic container.</value>
        [DataMember(Name = "min_point")]
        public Point3D MinPoint { get; set; } 
        /// <summary>
        /// A Point3D object for the maximum of the  bounding box around the graphic geometry. If None, then there must be an input for geometry and the bounding box around this geometry will be used to set up the graphic container.
        /// </summary>
        /// <value>A Point3D object for the maximum of the  bounding box around the graphic geometry. If None, then there must be an input for geometry and the bounding box around this geometry will be used to set up the graphic container.</value>
        [DataMember(Name = "max_point")]
        public Point3D MaxPoint { get; set; } 
        /// <summary>
        /// An Optional LegendParameters object to override default parameters of the legend. None indicates that default legend parameters will be used.
        /// </summary>
        /// <value>An Optional LegendParameters object to override default parameters of the legend. None indicates that default legend parameters will be used.</value>
        [DataMember(Name = "legend_parameters")]
        public LegendParameters LegendParameters { get; set; } 
        /// <summary>
        /// Optional DataType from the ladybug datatype subpackage (ie. Temperature()) , which will be used to assign default legend properties. If None, the legend associated with this object will contain no units unless a unit below is specified.
        /// </summary>
        /// <value>Optional DataType from the ladybug datatype subpackage (ie. Temperature()) , which will be used to assign default legend properties. If None, the legend associated with this object will contain no units unless a unit below is specified.</value>
        [DataMember(Name = "data_type")]
        public DataType DataType { get; set; } 
        /// <summary>
        /// Optional text string for the units of the values. (ie. \&quot;C\&quot;). If None, the default units of the data_type will be used.
        /// </summary>
        /// <value>Optional text string for the units of the values. (ie. \&quot;C\&quot;). If None, the default units of the data_type will be used.</value>
        [DataMember(Name = "unit")]
        public string Unit { get; set; }  = "";

        /// <summary>
        /// Returns the string presentation of the object
        /// </summary>
        /// <returns>String presentation of the object</returns>
        public override string ToString()
        {
            return "GraphicContainer";
        }

        /// <summary>
        /// Returns the string presentation of the object
        /// </summary>
        /// <returns>String presentation of the object</returns>
        public override string ToString(bool detailed)
        {
            if (!detailed)
                return this.ToString();
            
            var sb = new StringBuilder();
            sb.Append("GraphicContainer:\n");
            sb.Append("  Type: ").Append(Type).Append("\n");
            sb.Append("  Values: ").Append(Values).Append("\n");
            sb.Append("  Geometry: ").Append(Geometry).Append("\n");
            sb.Append("  MinPoint: ").Append(MinPoint).Append("\n");
            sb.Append("  MaxPoint: ").Append(MaxPoint).Append("\n");
            sb.Append("  LegendParameters: ").Append(LegendParameters).Append("\n");
            sb.Append("  DataType: ").Append(DataType).Append("\n");
            sb.Append("  Unit: ").Append(Unit).Append("\n");
            return sb.ToString();
        }
  
        /// <summary>
        /// Returns the object from JSON string
        /// </summary>
        /// <returns>GraphicContainer object</returns>
        public static GraphicContainer FromJson(string json)
        {
            var obj = JsonConvert.DeserializeObject<GraphicContainer>(json, JsonSetting.AnyOfConvertSetting);
            if (obj == null)
                return null;
            return obj.Type.ToLower() == obj.GetType().Name.ToLower() && obj.IsValid(throwException: true) ? obj : null;
        }

        /// <summary>
        /// Creates a new instance with the same properties.
        /// </summary>
        /// <returns>GraphicContainer object</returns>
        public virtual GraphicContainer DuplicateGraphicContainer()
        {
            return FromJson(this.ToJson());
        }

        /// <summary>
        /// Creates a new instance with the same properties.
        /// </summary>
        /// <returns>OpenAPIGenBaseModel</returns>
        public override OpenAPIGenBaseModel Duplicate()
        {
            return DuplicateGraphicContainer();
        }

        /// <summary>
        /// Creates a new instance with the same properties.
        /// </summary>
        /// <returns>OpenAPIGenBaseModel</returns>
        public override OpenAPIGenBaseModel DuplicateOpenAPIGenBaseModel()
        {
            return DuplicateGraphicContainer();
        }
     
        /// <summary>
        /// Returns true if objects are equal
        /// </summary>
        /// <param name="input">Object to be compared</param>
        /// <returns>Boolean</returns>
        public override bool Equals(object input)
        {
            input = input is AnyOf anyOf ? anyOf.Obj : input;
            return this.Equals(input as GraphicContainer);
        }

        /// <summary>
        /// Returns true if GraphicContainer instances are equal
        /// </summary>
        /// <param name="input">Instance of GraphicContainer to be compared</param>
        /// <returns>Boolean</returns>
        public bool Equals(GraphicContainer input)
        {
            if (input == null)
                return false;
            return base.Equals(input) && 
                (
                    this.Values == input.Values ||
                    Extension.AllEquals(this.Values, input.Values)
                ) && 
                    Extension.Equals(this.Type, input.Type) && 
                    Extension.Equals(this.Geometry, input.Geometry) && 
                    Extension.Equals(this.MinPoint, input.MinPoint) && 
                    Extension.Equals(this.MaxPoint, input.MaxPoint) && 
                    Extension.Equals(this.LegendParameters, input.LegendParameters) && 
                    Extension.Equals(this.DataType, input.DataType) && 
                    Extension.Equals(this.Unit, input.Unit);
        }

        /// <summary>
        /// Gets the hash code
        /// </summary>
        /// <returns>Hash code</returns>
        public override int GetHashCode()
        {
            unchecked // Overflow is fine, just wrap
            {
                int hashCode = base.GetHashCode();
                if (this.Values != null)
                    hashCode = hashCode * 59 + this.Values.GetHashCode();
                if (this.Type != null)
                    hashCode = hashCode * 59 + this.Type.GetHashCode();
                if (this.Geometry != null)
                    hashCode = hashCode * 59 + this.Geometry.GetHashCode();
                if (this.MinPoint != null)
                    hashCode = hashCode * 59 + this.MinPoint.GetHashCode();
                if (this.MaxPoint != null)
                    hashCode = hashCode * 59 + this.MaxPoint.GetHashCode();
                if (this.LegendParameters != null)
                    hashCode = hashCode * 59 + this.LegendParameters.GetHashCode();
                if (this.DataType != null)
                    hashCode = hashCode * 59 + this.DataType.GetHashCode();
                if (this.Unit != null)
                    hashCode = hashCode * 59 + this.Unit.GetHashCode();
                return hashCode;
            }
        }

        /// <summary>
        /// To validate all properties of the instance
        /// </summary>
        /// <param name="validationContext">Validation context</param>
        /// <returns>Validation Result</returns>
        IEnumerable<System.ComponentModel.DataAnnotations.ValidationResult> IValidatableObject.Validate(ValidationContext validationContext)
        {
            foreach(var x in base.BaseValidate(validationContext)) yield return x;

            

            
            // Type (string) pattern
            Regex regexType = new Regex(@"^GraphicContainer$", RegexOptions.CultureInvariant);
            if (this.Type != null && false == regexType.Match(this.Type).Success)
            {
                yield return new System.ComponentModel.DataAnnotations.ValidationResult("Invalid value for Type, must match a pattern of " + regexType, new [] { "Type" });
            }

            yield break;
        }
    }
}
